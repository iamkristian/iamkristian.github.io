<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Elastic Search - Hacking the Y-combinator | krx.io</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Elastic Search - Hacking the Y-combinator" />
<meta name="author" content="Kristian Rasmussen" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ve wanted to dive into Elastic search and see what it does for sometime. Mostly to see how it was working with it." />
<meta property="og:description" content="I’ve wanted to dive into Elastic search and see what it does for sometime. Mostly to see how it was working with it." />
<meta property="og:site_name" content="krx.io" />
<meta property="og:image" content="/IMG_6002.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-03-14T10:32:41+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="/IMG_6002.png" />
<meta property="twitter:title" content="Elastic Search - Hacking the Y-combinator" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kristian Rasmussen"},"dateModified":"2014-03-14T10:32:41+00:00","datePublished":"2014-03-14T10:32:41+00:00","description":"I’ve wanted to dive into Elastic search and see what it does for sometime. Mostly to see how it was working with it.","headline":"Elastic Search - Hacking the Y-combinator","image":"/IMG_6002.png","mainEntityOfPage":{"@type":"WebPage","@id":"/ruby/rails/elastic_search/2014/03/14/elastic_search-hacking-the-y-combinator.html"},"url":"/ruby/rails/elastic_search/2014/03/14/elastic_search-hacking-the-y-combinator.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="krx.io" />
<link rel="shortcut icon" type="image/x-icon" href="favicon-32x32.png"/>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">krx.io</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="/blog/">Blog</a>
            <a class="page-link" href="/about/">About me</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Elastic Search - Hacking the Y-combinator</h1>
    <p class="post-meta"><time class="dt-published" datetime="2014-03-14T10:32:41+00:00" itemprop="datePublished">
        Mar 14, 2014
      </time></p><img class="post-image" src="/assets/images/IMG_6002.png" alt=""/>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I’ve wanted to dive into Elastic search and see what it does for sometime. Mostly to see how it was working with it.</p>

<h2 id="search-basics">Search Basics</h2>

<p>When you first dive into search, there’s a couple of concepts you need to know about.</p>

<h3 id="documents">Documents</h3>

<p>We denormalize our data into documents. Typical use cases for applying a search engine is on heavily normalized data, that needs to be combined into arbitrary queries, that would make ordinary sql statements too slow or complex, thus joining multiple tables, to only return a few columns.</p>

<p>Other usecases could be fulltext search or geospatial data. Documents are represented by JSON, which makes it a delight to work with.</p>

<h3 id="the-index">The index</h3>

<p>Documents are stored in an index. The index is what we search in. As the name state, it is fast to lookup documents in it. In Eleastic Search, the index is a <a href="http://lucene.apache.org">lucene</a> based index. The greater part of the index is typically loaded into memory, but persisted to disc at index time. So it can be reloaded in case of a server failure.</p>

<h3 id="the-schema">The schema</h3>

<p>The document structure of the index is defined by a schema. In Elastic Search the schema is dynamic, so it’s possible to virtually throw anything at it.</p>

<p>In other lucene based search engines i.e. <a href="http://solr.apache.org">Solr</a>, the schema is static and singular to the server instance. This means the server will have to be reloaded in order for a schema change to take place, and only one index is served. This clearly has its disadvantages.</p>

<p>Te have some structure to the index, we provide a mappings. Which basically define the data types our document should consist of.</p>

<p>Here I’ve listed an entry for one of the documents.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"_index"</span><span class="p">:</span><span class="s2">"ycombinator"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_type"</span><span class="p">:</span><span class="s2">"items"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_id"</span><span class="p">:</span><span class="s2">"s6T7pwLNS8y1r4aUQXsoEA"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_score"</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="nl">"_source"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"identifier"</span><span class="p">:</span><span class="s2">"7375376"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"author"</span><span class="p">:</span><span class="s2">"summerdown2"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"content"</span><span class="p">:</span><span class="s2">"Very addictive and lots of fun :)"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"link"</span><span class="p">:</span><span class="s2">"item?id=7375376"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"points"</span><span class="p">:</span><span class="kc">null</span><span class="p">,</span><span class="w">
    </span><span class="nl">"parent"</span><span class="p">:</span><span class="mi">7373566</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="indexes-shards-replica-nodes-clusters">Indexes, Shards, Replica, Nodes, Clusters</h3>

<p>Elastic Search operates with multiple indexes. A single index is made of shards, which can be scattered over multiple nodes in a cluster. Each shard can have a replica, which is an exact copy of a shard. This is used to enhance search performance, and as duplication in case of failure.</p>

<p>Indexes support basic create and delete operations on the fly.</p>

<h2 id="indexing">Indexing</h2>

<p>So getting data into the search engine is actually a project on its own. Basically there are two ways of populating an index.</p>

<ul>
  <li>Push data to elastic search, when it is modified</li>
  <li>Query the database for delta changes</li>
</ul>

<p>The first strategy works nicely if you have a monolithic system of one. If you have multiple sub systems that interact with your data, it would make sense to query the database for deltas.</p>

<p>The indexing task for this project is querying the database, because faults might appear when parsing the ycombinator for data.</p>

<p>Looking at the <code class="language-plaintext highlighter-rouge">Item</code> the record boils down to</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'elastic'</span>

<span class="k">class</span> <span class="nc">Item</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">def</span> <span class="nf">re_index</span>
    <span class="n">elastic</span> <span class="o">=</span> <span class="no">Elastic</span><span class="p">.</span><span class="nf">instance</span>
    <span class="n">body</span> <span class="o">=</span> <span class="no">ItemSerializer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">).</span><span class="nf">to_json</span>
    <span class="n">elastic</span><span class="p">.</span><span class="nf">add_item</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<p>The serializer is a simple <code class="language-plaintext highlighter-rouge">ActiveModel::Serializer</code> which removes the root element and adds the attributes I want in the index.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ItemSerializer</span> <span class="o">&lt;</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Serializer</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">root</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="n">attributes</span> <span class="ss">:identifier</span><span class="p">,</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">:content</span><span class="p">,</span> <span class="ss">:link</span><span class="p">,</span> <span class="ss">:points</span><span class="p">,</span> <span class="ss">:parent</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The interaction with ElasticSearch is wrapped in the <code class="language-plaintext highlighter-rouge">Elastic</code> class.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'elasticsearch'</span>

<span class="k">class</span> <span class="nc">Elastic</span>
  <span class="kp">include</span> <span class="no">Singleton</span>

  <span class="c1"># This creates the index and types at</span>
  <span class="c1"># '/name/type/'</span>
  <span class="c1"># making the documents available</span>
  <span class="k">def</span> <span class="nf">create_index</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
    <span class="n">client</span><span class="p">.</span><span class="nf">index</span> <span class="ss">index: </span><span class="nb">name</span><span class="p">,</span> <span class="ss">type: </span><span class="n">type</span><span class="p">,</span> <span class="ss">body: </span><span class="n">body</span>
  <span class="k">end</span>

  <span class="c1"># Adds documents of type items to the index ycombinator</span>
  <span class="k">def</span> <span class="nf">add_item</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
    <span class="n">create_index</span><span class="p">(</span><span class="s1">'ycombinator'</span><span class="p">,</span> <span class="s1">'items'</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Creates the ElasticSearch client</span>
  <span class="k">def</span> <span class="nf">client</span>
    <span class="no">Elasticsearch</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span> <span class="ss">log: </span><span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="queries">Queries</h2>

<p>Finding things again in the index is nicely done using the lucene syntax.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Basic syntax
http://localhost:9200/ycombinator/items/_search?q=&lt;query&gt;

Giving query the following:
author:gebe        # Will return documents with author gebe
+author:gebe       # Will make author=gebe mandatory for results
-author:gebe       # Will make exclude author gebe from results
</code></pre></div></div>
<p>Querying throug the gem would add this to the <code class="language-plaintext highlighter-rouge">Elastic</code> class</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">client</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="ss">index: </span><span class="s1">'ycombinator'</span><span class="p">,</span> <span class="ss">type: </span><span class="s1">'items'</span><span class="p">,</span> <span class="ss">body: </span><span class="n">options</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>
<p>A search for the string <code class="language-plaintext highlighter-rouge">nice</code> in the content would look like this</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="n">es</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span> <span class="ss">query: </span><span class="p">{</span> <span class="ss">match: </span><span class="p">{</span> <span class="ss">content: </span><span class="s1">'nice'</span> <span class="p">}</span> <span class="p">}</span> <span class="p">)</span>
</code></pre></div></div>

<h2 id="facets">Facets</h2>

<p>Facets are a way of summerizing on the data in the index. Lets assume I want to find how many items an author have created, I could as the index to facet over authors.</p>

<p>This would change our query to this</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="n">es</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span> <span class="ss">query: </span><span class="p">{</span> <span class="ss">match: </span><span class="p">{</span> <span class="ss">content: </span><span class="s1">'nice'</span><span class="p">}},</span>
            <span class="ss">facets: </span><span class="p">{</span> <span class="ss">tags: </span><span class="p">{</span> <span class="ss">terms: </span><span class="p">{</span> <span class="ss">field: </span><span class="s1">'author'</span> <span class="p">}</span> <span class="p">}}</span> <span class="p">)</span>
</code></pre></div></div>
<p>This actually combines the search result with the facets.</p>

<h2 id="more">More</h2>

<p>This is far from an exhaustive example of ElasticSearch. More a sort of scratching the surface.</p>

<p>If you want to check out the code I used, you can find it on <a href="http://github.com/iamkristian/elastic-talk">Github</a></p>


  </div><a class="u-url" href="/ruby/rails/elastic_search/2014/03/14/elastic_search-hacking-the-y-combinator.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Kristian Rasmussen</li>
          <li><a class="u-email" href="mailto:me@krx.io">me@krx.io</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>This should contain some nice description of what this is all about. Can&#39;t say that I&#39;m entirely sure, except fun, code and thoughts from me.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
  <a rel="me" href="https://github.com/iamkristian" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.instagram.com/iamkristian" target="_blank" title="instagram">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#instagram"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.linkedin.com/in/iamkristian" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.youtube.com/jekyll" target="_blank" title="youtube">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#youtube"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://iamkristian.github.io/feed.xml" target="_blank" title="rss">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
    </svg>
  </a>
</li>
</ul>
</div>

  </div>

</footer>
</body>

</html>
